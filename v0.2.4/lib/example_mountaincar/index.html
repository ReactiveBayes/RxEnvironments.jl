<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example: Mountain Car · RxEnvironments.jl</title><meta name="title" content="Example: Mountain Car · RxEnvironments.jl"/><meta property="og:title" content="Example: Mountain Car · RxEnvironments.jl"/><meta property="twitter:title" content="Example: Mountain Car · RxEnvironments.jl"/><meta name="description" content="Documentation for RxEnvironments.jl."/><meta property="og:description" content="Documentation for RxEnvironments.jl."/><meta property="twitter:description" content="Documentation for RxEnvironments.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RxEnvironments.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Example: Mountain Car</a><ul class="internal"><li><a class="tocitem" href="#Environment-details"><span>Environment details</span></a></li><li><a class="tocitem" href="#RxEnvironments-design-pattern"><span>RxEnvironments design pattern</span></a></li><li><a class="tocitem" href="#Implementing-the-environment"><span>Implementing the environment</span></a></li></ul></li><li><a class="tocitem" href="../advanced_usage/">Advanced Usage</a></li><li><a class="tocitem" href="../philosophy/">Design Philosophy</a></li><li><a class="tocitem" href="../api_reference/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Example: Mountain Car</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example: Mountain Car</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/biaslab/RxEnvironments.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/biaslab/RxEnvironments.jl/blob/main/docs/src/lib/example_mountaincar.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="lib-mountain-car"><a class="docs-heading-anchor" href="#lib-mountain-car">Example: Mountain Car Environment</a><a id="lib-mountain-car-1"></a><a class="docs-heading-anchor-permalink" href="#lib-mountain-car" title="Permalink"></a></h1><p>On this page we will work out a more advanced example of an environment in <code>RxEnvironments</code>. The code on this page is the implementation of the Mountain Car environment in the core of the package. </p><h2 id="Environment-details"><a class="docs-heading-anchor" href="#Environment-details">Environment details</a><a id="Environment-details-1"></a><a class="docs-heading-anchor-permalink" href="#Environment-details" title="Permalink"></a></h2><p>The mountain car environment is a classical environment that first appeared in <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-209.pdf">Andrew Moore&#39;s PhD thesis</a>, where a car is placed in the valley of a mountainous landscape. The car can apply accelerations to its position, and the goal is to get the car up the hills adjacent to the valley. However, the engine power of the car alone is not enough to get out of the valley, and thus the agents in the environment should figure out that it can use the additional speed gained from driving up and down the hill on the other side to get to the desired location. The agent therefore can conduct action <span>$a \in [-1, 1]$</span> to change the direction and intensity of the engine force.</p><p>There are several forces that work on the car, namely:</p><ul><li>Gravitational force from the slope of the landscape.</li><li>Friction force from movement.</li><li>The power exerted by the engine of the car.</li></ul><p>The gravitational force can be computed as follows, here <span>$m$</span> is the mass of the car, <span>$l(x)$</span> the landscape function as function of horizontal position <span>$x$</span>:</p><p class="math-container">\[F_g(x, m, l) = -9.81 \cdot m \cdot \left( \sin \arctan \frac{dl}{dx}(x)\right)\]</p><p>The friction force is linear in the velocity <span>$v$</span> and the friction coefficient <span>$c_f$</span> of the car:</p><p class="math-container">\[F_f(v, c_f) = - v \cdot c_f\]</p><p>The engine power is a direct effect of action <span>$a$</span>, and is scaled by constant engine power <span>$c_e$</span>:</p><p class="math-container">\[F_e(a, c_e) = a \cdot c_e\]</p><h2 id="RxEnvironments-design-pattern"><a class="docs-heading-anchor" href="#RxEnvironments-design-pattern">RxEnvironments design pattern</a><a id="RxEnvironments-design-pattern-1"></a><a class="docs-heading-anchor-permalink" href="#RxEnvironments-design-pattern" title="Permalink"></a></h2><p>The environment details explained above describe a set of differential equations governing the location and velocity of the car. In <a href="https://mgoulao.github.io/gym-docs/environments/classic_control/mountain_car_continuous/">classical implementations</a> of the mountain car environment, the timestep is fixed and the differential equation is solved with the <a href="https://en.wikipedia.org/wiki/Euler_method">Euler method</a>. However, in <code>RxEnvironments</code> we have continuous time environments that are realized by varying the timestep between environment state updates. Therefore, using Euler&#39;s method to solve the system of differential equations accumulates errors in every timestep, and running the same environment twice might give us different realizations of the environment dynamics because of the way the errors are accumulated with varying timesteps between state updates. </p><p>In order to still get consistent simulations, the following design pattern may be of use when building an environment in <code>RxEnvironments</code>, and we will also employ this design pattern when implementing the Mountain Car environment: We use the <code>DifferentialEquations.jl</code> package to determine the trajectory of a moving object over a longer period of time and save this in the state of the object. Then, whenever we have to do a state update, we first determine whether or not the trajectory is still valid (for example, there were no collisions or actions conducted that change the trajectory of the object). If the trajectory is still valid, we simply return the desired value from the precomputed trajectory. If the trajectory is not valid anymore, we recompute the trajectory with the updated state of the object and save the new trajectory in the state of the object. In this way, we obtain a consistent and accurate state update irrespective of the varying timestep size of the state updates.</p><h2 id="Implementing-the-environment"><a class="docs-heading-anchor" href="#Implementing-the-environment">Implementing the environment</a><a id="Implementing-the-environment-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-the-environment" title="Permalink"></a></h2><p>Now that we&#39;ve specified the environment dynamics and the design pattern for getting accurate state updates, it is time to implement the environment in <code>RxEnvironments</code>.</p><h3 id="Setup"><a class="docs-heading-anchor" href="#Setup">Setup</a><a id="Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Setup" title="Permalink"></a></h3><p>For this environment we have some specific requirements, please make sure these are installed. Furthermore, we define a generic landscape function to utilize, but the environment will also work with other (differentiable) landscape functions.</p><pre><code class="language-julia hljs">import HypergeometricFunctions: _₂F₁
using Distributions
using ForwardDiff
using DifferentialEquations
using LinearAlgebra
using RxEnvironments

function landscape(x)
    if x &lt; 0
        h = x^2 + x
    else
        h =
            x * _₂F₁(0.5, 0.5, 1.5, -5 * x^2) +
            x^3 * _₂F₁(1.5, 1.5, 2.5, -5 * x^2) / 3 +
            x^5 / 80
    end
    return 0.05 * h
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">landscape (generic function with 1 method)</code></pre><h3 id="Defining-environment-structures"><a class="docs-heading-anchor" href="#Defining-environment-structures">Defining environment structures</a><a id="Defining-environment-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-environment-structures" title="Permalink"></a></h3><p>In order to implement the design pattern described above, we need to create a structure in which we are going to store the precomputed trajectory of the mountain car:</p><pre><code class="language-julia hljs">mutable struct MountainCarTrajectory
    recompute::Bool
    time_left::Real
    trajectory::Any
    T::Real
end

# Convenient getters and setters
recompute(trajectory::MountainCarTrajectory) = trajectory.recompute
time_left(trajectory::MountainCarTrajectory) = trajectory.time_left
current_time(trajectory::MountainCarTrajectory) =
    total_time(trajectory) - time_left(trajectory)
total_time(trajectory::MountainCarTrajectory) = trajectory.T
Base.getindex(trajectory::MountainCarTrajectory, index) = trajectory.trajectory(index)


set_recompute!(trajectory::MountainCarTrajectory, recompute) =
    trajectory.recompute = recompute
set_time_left!(trajectory::MountainCarTrajectory, time_left) =
    trajectory.time_left = time_left
reduce_time_left!(trajectory::MountainCarTrajectory, elapsed_time) =
    set_time_left!(trajectory, time_left(trajectory) - elapsed_time)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">reduce_time_left! (generic function with 1 method)</code></pre><p>Here, we also implement all helper functions that give us a convenient interface to work with this trajectory. This trajectory is wrapped in the state of a Mountain Car, which contains all variables of the mountain car that are subject to change, such as position and velocity.</p><pre><code class="language-julia hljs">mutable struct MountainCarState
    position::Real
    velocity::Real
    throttle::Real
    trajectory::MountainCarTrajectory
end

# Convenient getters and setters
position(state::MountainCarState) = state.position
velocity(state::MountainCarState) = state.velocity
throttle(state::MountainCarState) = state.throttle
observable_state(state::MountainCarState) = [position(state), velocity(state)]

set_position!(state::MountainCarState, position::Real) = state.position = position
set_velocity!(state::MountainCarState, velocity::Real) = state.velocity = velocity
set_throttle!(state::MountainCarState, throttle::Real) = state.throttle = throttle
set_trajectory!(state::MountainCarState, trajectory) = state.trajectory = trajectory
trajectory(state::MountainCarState) = state.trajectory

# Convenient constructor that creates an empty trajectory that will immediately be replaced.
MountainCarState(position::Real, velocity::Real, throttle::Real) = MountainCarState(
    position,
    velocity,
    throttle,
    MountainCarTrajectory(true, 0.0, [], 0.0),
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.MountainCarState</code></pre><p>The actual Mountain Car struct will contain the state of the mountain car, as well as constants such as the engine power and friction coefficient:</p><pre><code class="language-julia hljs">struct MountainCarAgent
    state::MountainCarState
    engine_power::Real
    friction_coefficient::Real
    mass::Real
    target::Real
end

MountainCarAgent(
    position::Real,
    engine_power::Real,
    friction_coefficient::Real,
    mass::Real,
    target::Real,
) = MountainCarAgent(
    MountainCarState(position, 0.0, 0.0),
    engine_power,
    friction_coefficient,
    mass,
    target,
)

# Convenient getters and setters
state(car::MountainCarAgent) = car.state
position(car::MountainCarAgent) = position(state(car))
velocity(car::MountainCarAgent) = velocity(state(car))
throttle(car::MountainCarAgent) = throttle(state(car))
mass(car::MountainCarAgent) = car.mass
observable_state(car::MountainCarAgent) = observable_state(state(car))

set_position!(car::MountainCarAgent, position::Real) = set_position!(state(car), position)
set_velocity!(car::MountainCarAgent, velocity::Real) = set_velocity!(state(car), velocity)
set_throttle!(car::MountainCarAgent, throttle::Real) = set_throttle!(state(car), throttle)
engine_power(car::MountainCarAgent) = car.engine_power
friction_coefficient(car::MountainCarAgent) = car.friction_coefficient
set_trajectory!(car::MountainCarAgent, trajectory) = set_trajectory!(state(car), trajectory)
trajectory(car::MountainCarAgent) = trajectory(state(car))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">trajectory (generic function with 2 methods)</code></pre><p>Now we are in a shape where we can define the actual environment, which will contain a landscape function and a collection of Mountain Cars:</p><pre><code class="language-julia hljs">struct MountainCarEnvironment
    actors::Vector{MountainCarAgent}
    landscape::Any
end

MountainCarEnvironment(landscape) = MountainCarEnvironment([], landscape)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.MountainCarEnvironment</code></pre><p>In order to encode the actions conducted by mountain car entities on the environment, we introduce a <code>Throttle</code> struct that clamps an input action between <span>$-1$</span> and <span>$1$</span>:</p><pre><code class="language-julia hljs">struct Throttle
    throttle::Real
    Throttle(throttle::Real) = new(clamp(throttle, -1, 1))
end</code></pre><p>Our environment contains a field <code>actors</code>, however, we still have to tell <code>RxEnvironments</code> how to add entities to this field:</p><pre><code class="language-julia hljs">function RxEnvironments.add_to_state!(environment::MountainCarEnvironment, agent::MountainCarAgent)
    push!(environment.actors, agent)
end</code></pre><h3 id="Environment-dynamics"><a class="docs-heading-anchor" href="#Environment-dynamics">Environment dynamics</a><a id="Environment-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Environment-dynamics" title="Permalink"></a></h3><p>When simulating the environment dynamics we need to be able to calculate all forces exerted on the car at any point in time:</p><pre><code class="language-julia hljs">throttle(action::Throttle) = action.throttle
friction(car::MountainCarAgent, velocity) = velocity * -friction_coefficient(car)
gravitation(car::MountainCarAgent, position, landscape) =
    mass(car) * -9.81 * sin(atan(ForwardDiff.derivative(landscape, position)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">gravitation (generic function with 1 method)</code></pre><h3 id="Solving-the-differential-equations"><a class="docs-heading-anchor" href="#Solving-the-differential-equations">Solving the differential equations</a><a id="Solving-the-differential-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-differential-equations" title="Permalink"></a></h3><p>We have set up the infrastructure with which we can save a trajectory of a moving object in its state, and retrieve this trajectory during future state updates. For this, we use the <a href="https://docs.sciml.ai/DiffEqDocs/stable/"><code>DifferentialEquations.jl</code></a> package, and we refer to the documentation of the <code>DifferentialEquations.jl</code> package for a more comprehensive explanation of solving differential equations in Julia. This section merely shows an example of the desired design pattern in <code>RxEnvironments.jl</code>. We have to compute the dynamics of the mountain car and save this in the state of the mountain car:</p><pre><code class="language-julia hljs"># DifferentialEquations.jl function describing the environment dynamics.
function __mountain_car_dynamics(du, u, s, t)
    agent, env = s
    position, momentum = u
    du[1] = momentum
    du[2] =
        throttle(agent) +
        friction(agent, momentum) +
        gravitation(agent, position, env.landscape)
end

# Function that computes a trajectory for a mountain car for 5 seconds ahead and saves this result in the state of the corresponding car.
function __compute_mountain_car_dynamics(
    agent::MountainCarAgent,
    environment::MountainCarEnvironment,
)
    T = 5.0
    initial_state = [position(agent), velocity(agent)]
    tspan = (0.0, T)
    prob = ODEProblem(__mountain_car_dynamics, initial_state, tspan, (agent, environment))
    sol = solve(prob, Tsit5())
    set_trajectory!(agent, MountainCarTrajectory(false, T, sol, T))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">__compute_mountain_car_dynamics (generic function with 1 method)</code></pre><h3 id="Implementing-RxEnvironments-functions"><a class="docs-heading-anchor" href="#Implementing-RxEnvironments-functions">Implementing <code>RxEnvironments</code> functions</a><a id="Implementing-RxEnvironments-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-RxEnvironments-functions" title="Permalink"></a></h3><p>All code we have written so far has served as setup for our environment, and we haven&#39;t written any core <code>RxEnvironments.jl</code> code yet. In this section we will write and elaborate on the necessary code to make our environment fully reactive. </p><p><code>RxEnvironments.jl</code> requires us to implement 3 functions specifically for our environment: <code>what_to_send</code>, <code>receive!</code> and <code>update!</code>: <code>what_to_send(recipient, emitter)</code> determines the message <code>emitter</code> sends to <code>recipient</code>. In our example, this function describes how the environment presents an observation to the agent, as function of the environment state. <code>receive!(recipient, emitter, observation)</code> determines how <code>observation</code> sent from <code>emitter</code> to <code>recipient</code> influences the internal state of <code>recipient</code>. In our example, this describes how a <code>Throttle</code> action from the agent changes the environment state. <code>update!(entity, elapsed_time)</code> describes the state transition of <code>entity</code> for <code>elapsed_time</code> if there are no incoming observations. In our example, this is how the environment gravity and friction influence the position and velocity of the agent inbetween agent actions. A notable detail is that, with our differential equations solution, we also have to check whenever we <code>update!</code> the environment if we have to recompute the trajectory for a mountain car, and whenever we <code>receive!</code> an action from an agent, that we should always recompute the trajectory.</p><pre><code class="language-julia hljs"># The agent observes a noisy estimate of its actual position and velocity
RxEnvironments.what_to_send(agent::MountainCarAgent, environment::MountainCarEnvironment) =
    return rand(MvNormal(observable_state(agent), I(2)))

function RxEnvironments.receive!(
    environment::MountainCarEnvironment,
    agent::MountainCarAgent,
    action::Throttle,
)
    # We always have to recompute the trajecory of an agent if this agent conducts an action
    set_recompute!(trajectory(agent), true)
    set_throttle!(agent, throttle(action) * engine_power(agent))
end

function RxEnvironments.update!(environment::MountainCarEnvironment, elapsed_time::Real)
    # Update all actors in the environment
    for agent in environment.actors
        # If we have conducted an action or the current trajecory is valid for less than `elapsed_time` seconds, recompute
        if recompute(trajectory(agent)) || time_left(trajectory(agent)) &lt; elapsed_time
            __compute_mountain_car_dynamics(agent, environment)
        end
        # Bookkeeping for the trajecory, position and velocity
        reduce_time_left!(trajectory(agent), elapsed_time)
        new_state = trajectory(agent)[current_time(trajectory(agent))]
        set_position!(agent, new_state[1])
        set_velocity!(agent, new_state[2])
    end
end</code></pre><p>With these funcitons we have specified the full environment behaviour, and the environment is now fully functional in <code>RxEnvironments.jl</code>.  We can create the environment with the <code>RxEnvironment</code> factory method:</p><pre><code class="language-julia hljs">car_engine_power = 0.6
car_friction_coefficient = 0.5
car_mass = 2
car_target = 1

env = RxEnvironment(MountainCarEnvironment(landscape))
agent = add!(
            env,
            MountainCarAgent(
                MountainCarState(-0.5, 0.0, 0.0),
                car_engine_power,
                car_friction_coefficient,
                car_mass,
                car_target,
            ),
        )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Continuous RxEntity{Main.MountainCarAgent}</code></pre><h3 id="Discrete-time-Mountain-Car"><a class="docs-heading-anchor" href="#Discrete-time-Mountain-Car">Discrete-time Mountain Car</a><a id="Discrete-time-Mountain-Car-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-time-Mountain-Car" title="Permalink"></a></h3><p>Classical control theory mainly deals with discrete-time environments, and it is actually very easy to convert the environment dynamics we have written in <code>RxEnvironments</code> to also define a discrete environment. In general, we can implement the <code>time_interval</code> function:</p><pre><code class="language-julia hljs">time_interval(env::YourEnvironment) = dt</code></pre><p>for your choice of <code>dt</code>. For our mountain car environment, we can set the default timestep to <span>$0.1$</span> as follows:</p><pre><code class="language-julia hljs">time_interval(env::MountainCarEnvironment) = 0.1</code></pre><p>This will still utilize all environment dynamics we have written for the continuous case, but will create a discrete-time environment. In order to create a discrete-time environment, please make sure to include the <code>discrete=true</code> keyword argument for the <code>RxEnvironment</code> factory method:</p><pre><code class="language-julia hljs">car_engine_power = 0.6
car_friction_coefficient = 0.5
car_mass = 2
car_target = 1

env = RxEnvironment(MountainCarEnvironment(landscape); is_discrete=true)
agent = add!(
            env,
            MountainCarAgent(
                MountainCarState(-0.5, 0.0, 0.0),
                car_engine_power,
                car_friction_coefficient,
                car_mass,
                car_target,
            ),
        )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Discrete RxEntity{Main.MountainCarAgent}</code></pre><h3 id="Animating-the-state-of-the-environment"><a class="docs-heading-anchor" href="#Animating-the-state-of-the-environment">Animating the state of the environment</a><a id="Animating-the-state-of-the-environment-1"></a><a class="docs-heading-anchor-permalink" href="#Animating-the-state-of-the-environment" title="Permalink"></a></h3><p>In order to animate the state of the environment, we have to install <code>GLMakie.jl</code> and implement the <code>plot_state</code> function for our environment.</p><pre><code class="language-julia hljs">using GLMakie

function RxEnvironments.plot_state(ax, environment::MountainCarEnvironment)
    x = range(-2.5, 2.5, 100)
    y = environment.landscape.(x)
    lines!(ax, x, y)
    for agent in environment.actors
        pos = position(agent)
        scatter!(ax, pos, environment.landscape(pos))
    end
end</code></pre><p>Now we can call:</p><pre><code class="language-julia hljs">animate_state(env)</code></pre><p>on an existing <code>RxEnvironment</code> wrapping the <code>MountainCarEnvironment</code> and obtain a similar visualization: <img src="../../img/animate_state.png" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting Started</a><a class="docs-footer-nextpage" href="../advanced_usage/">Advanced Usage »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 30 January 2024 13:26">Tuesday 30 January 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
