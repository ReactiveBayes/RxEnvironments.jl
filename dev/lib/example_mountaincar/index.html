<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example: Mountain Car · RxEnvironments.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RxEnvironments.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Example: Mountain Car</a><ul class="internal"><li><a class="tocitem" href="#Environment-details"><span>Environment details</span></a></li><li class="toplevel"><a class="tocitem" href="#Convenient-getters-and-setters"><span>Convenient getters and setters</span></a></li><li class="toplevel"><a class="tocitem" href="#Convenient-getters-and-setters-2"><span>Convenient getters and setters</span></a></li><li class="toplevel"><a class="tocitem" href="#Convenient-constructor-that-creates-an-empty-trajectory-that-will-immediately-be-replaced."><span>Convenient constructor that creates an empty trajectory that will immediately be replaced.</span></a></li><li class="toplevel"><a class="tocitem" href="#Convenient-getters-and-setters-3"><span>Convenient getters and setters</span></a></li><li class="toplevel"><a class="tocitem" href="#DifferentialEquations.jl-function-describing-the-environment-dynamics."><span>DifferentialEquations.jl function describing the environment dynamics.</span></a></li><li class="toplevel"><a class="tocitem" href="#Function-that-computes-a-trajectory-for-a-mountain-car-for-5-seconds-ahead-and-saves-this-result-in-the-state-of-the-corresponding-car."><span>Function that computes a trajectory for a mountain car for 5 seconds ahead and saves this result in the state of the corresponding car.</span></a></li><li class="toplevel"><a class="tocitem" href="#The-agent-observes-a-noisy-estimate-of-its-actual-position-and-velocity"><span>The agent observes a noisy estimate of its actual position and velocity</span></a></li></ul></li><li><a class="tocitem" href="../advanced_usage/">Advanced Usage</a></li><li><a class="tocitem" href="../philosophy/">Design Philosophy</a></li><li><a class="tocitem" href="../api_reference/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Example: Mountain Car</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example: Mountain Car</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/biaslab/RxEnvironments.jl/blob/main/docs/src/lib/example_mountaincar.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="lib-mountain-car"><a class="docs-heading-anchor" href="#lib-mountain-car">Example: Mountain Car Environment</a><a id="lib-mountain-car-1"></a><a class="docs-heading-anchor-permalink" href="#lib-mountain-car" title="Permalink"></a></h1><p>On this page we will work out a more advanced example of an environment in <code>RxEnvironments</code>. The code on this page is the implementation of the Mountain Car environment in the core of the package. </p><h2 id="Environment-details"><a class="docs-heading-anchor" href="#Environment-details">Environment details</a><a id="Environment-details-1"></a><a class="docs-heading-anchor-permalink" href="#Environment-details" title="Permalink"></a></h2><p>The mountain car environment is a classical environment that first appeared in <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-209.pdf">Andrew Moore&#39;s PhD thesis</a>, where a car is placed in the valley of a mountainous landscape. The car can apply accelerations to its position, and the goal is to get the car up the hills adjacent to the valley. However, the engine power of the car alone is not enough to get out of the valley, and thus the agents in the environment should figure out that it can use the additional speed gained from driving up and down the hill on the other side to get to the desired location. The agent therefore can conduct action <span>$a \in [-1, 1]$</span> to change the direction and intensity of the engine force.</p><p>There are several forces that work on the car, namely:</p><ul><li>Gravitational force from the slope of the landscape.</li><li>Friction force from movement.</li><li>The power exerted by the engine of the car.</li></ul><p>The gravitational force can be computed as follows, here <span>$m$</span> is the mass of the car, <span>$l(x)$</span> the landscape function as function of horizontal position <span>$x$</span>:</p><p class="math-container">\[ F_g(x, m, l) = -9.81 \cdot m \cdot \left( \sin \arctan \frac{dl}{dx}(x)\right)
 ```

The friction force is linear in the velocity $v$ and the friction coefficient $c_f$ of the car:\]</p><p>math F<em>f(v, c</em>f) = - v \cdot c_f</p><pre><code class="nohighlight hljs">
The engine power is a direct effect of action $a$, and is scaled by constant engine power $c_e$:
</code></pre><p>math F<em>e(a, c</em>e) = a \cdot c_e</p><pre><code class="nohighlight hljs">
## RxEnvironments design pattern
The environment details explained above describe a set of differential equations governing the location and velocity of the car. In [classical implementations](https://mgoulao.github.io/gym-docs/environments/classic_control/mountain_car_continuous/) of the mountain car environment, the timestep is fixed and the differential equation is solved with the [Euler method](https://en.wikipedia.org/wiki/Euler_method). However, in `RxEnvironments` we have continuous time environments that are realized by varying the timestep between environment state updates. Therefore, using Euler&#39;s method to solve the system of differential equations accumulates errors in every timestep, and running the same environment twice might give us different realizations of the environment dynamics because of the way the errors are accumulated with varying timesteps between state updates. 

In order to still get consistent simulations, the following design pattern may be of use when building an environment in `RxEnvironments`, and we will also employ this design pattern when implementing the Mountain Car environment: We use the `DifferentialEquations.jl` package to determine the trajectory of a moving object over a longer period of time and save this in the state of the object. Then, whenever we have to do a state update, we first determine whether or not the trajectory is still valid (for example, there were no collisions or actions conducted that change the trajectory of the object). If the trajectory is still valid, we simply return the desired value from the precomputed trajectory. If the trajectory is not valid anymore, we recompute the trajectory with the updated state of the object and save the new trajectory in the state of the object. In this way, we obtain a consistent and accurate state update irrespective of the varying timestep size of the state updates.
## Implementing the environment
Now that we&#39;ve specified the environment dynamics and the design pattern for getting accurate state updates, it is time to implement the environment in `RxEnvironments`.
### Setup
For this environment we have some specific requirements, please make sure these are installed. Furthermore, we define a generic landscape function to utilize, but the environment will also work with other (differentiable) landscape functions.</code></pre><p>julia import HypergeometricFunctions: _₂F₁ using Distributions using ForwardDiff using DifferentialEquations using LinearAlgebra using RxEnvironments</p><p>function landscape(x)     if x &lt; 0         h = x^2 + x     else         h =             x * _₂F₁(0.5, 0.5, 1.5, -5 * x^2) +             x^3 * _₂F₁(1.5, 1.5, 2.5, -5 * x^2) / 3 +             x^5 / 80     end     return 0.05 * h end</p><pre><code class="nohighlight hljs">### Defining environment structures
In order to implement the design pattern described above, we need to create a structure in which we are going to store the precomputed trajectory of the mountain car:</code></pre><p>julia</p><p>mutable struct MountainCarTrajectory     recompute::Bool     time_left::Real     trajectory::Any     T::Real end</p><h1 id="Convenient-getters-and-setters"><a class="docs-heading-anchor" href="#Convenient-getters-and-setters">Convenient getters and setters</a><a id="Convenient-getters-and-setters-1"></a><a class="docs-heading-anchor-permalink" href="#Convenient-getters-and-setters" title="Permalink"></a></h1><p>recompute(trajectory::MountainCarTrajectory) = trajectory.recompute time<em>left(trajectory::MountainCarTrajectory) = trajectory.time</em>left current<em>time(trajectory::MountainCarTrajectory) =     total</em>time(trajectory) - time<em>left(trajectory) total</em>time(trajectory::MountainCarTrajectory) = trajectory.T Base.getindex(trajectory::MountainCarTrajectory, index) = trajectory.trajectory(index)</p><p>set<em>recompute!(trajectory::MountainCarTrajectory, recompute) =     trajectory.recompute = recompute set</em>time<em>left!(trajectory::MountainCarTrajectory, time</em>left) =     trajectory.time<em>left = time</em>left reduce<em>time</em>left!(trajectory::MountainCarTrajectory, elapsed<em>time) =     set</em>time<em>left!(trajectory, time</em>left(trajectory) - elapsed_time)</p><pre><code class="nohighlight hljs">Here, we also implement all helper functions that give us a convenient interface to work with this trajectory. This trajectory is wrapped in the state of a Mountain Car, which contains all variables of the mountain car that are subject to change, such as position and velocity.</code></pre><p>julia</p><p>mutable struct MountainCarState     position::Real     velocity::Real     throttle::Real     trajectory::MountainCarTrajectory end</p><h1 id="Convenient-getters-and-setters-2"><a class="docs-heading-anchor" href="#Convenient-getters-and-setters-2">Convenient getters and setters</a><a class="docs-heading-anchor-permalink" href="#Convenient-getters-and-setters-2" title="Permalink"></a></h1><p>position(state::MountainCarState) = state.position velocity(state::MountainCarState) = state.velocity throttle(state::MountainCarState) = state.throttle observable_state(state::MountainCarState) = [position(state), velocity(state)]</p><p>set<em>position!(state::MountainCarState, position::Real) = state.position = position set</em>velocity!(state::MountainCarState, velocity::Real) = state.velocity = velocity set<em>throttle!(state::MountainCarState, throttle::Real) = state.throttle = throttle set</em>trajectory!(state::MountainCarState, trajectory) = state.trajectory = trajectory trajectory(state::MountainCarState) = state.trajectory</p><h1 id="Convenient-constructor-that-creates-an-empty-trajectory-that-will-immediately-be-replaced."><a class="docs-heading-anchor" href="#Convenient-constructor-that-creates-an-empty-trajectory-that-will-immediately-be-replaced.">Convenient constructor that creates an empty trajectory that will immediately be replaced.</a><a id="Convenient-constructor-that-creates-an-empty-trajectory-that-will-immediately-be-replaced.-1"></a><a class="docs-heading-anchor-permalink" href="#Convenient-constructor-that-creates-an-empty-trajectory-that-will-immediately-be-replaced." title="Permalink"></a></h1><p>MountainCarState(position::Real, velocity::Real, throttle::Real) = MountainCarState(     position,     velocity,     throttle,     MountainCarTrajectory(true, 0.0, [], 0.0), )</p><pre><code class="nohighlight hljs">
The actual Mountain Car struct will contain the state of the mountain car, as well as constants such as the engine power and friction coefficient:</code></pre><p>julia</p><p>struct MountainCarAgent     state::MountainCarState     engine<em>power::Real     friction</em>coefficient::Real     mass::Real     target::Real end</p><p>MountainCarAgent(     position::Real,     engine<em>power::Real,     friction</em>coefficient::Real,     mass::Real,     target::Real, ) = MountainCarAgent(     MountainCarState(position, 0.0, 0.0),     engine<em>power,     friction</em>coefficient,     mass,     target, )</p><h1 id="Convenient-getters-and-setters-3"><a class="docs-heading-anchor" href="#Convenient-getters-and-setters-3">Convenient getters and setters</a><a class="docs-heading-anchor-permalink" href="#Convenient-getters-and-setters-3" title="Permalink"></a></h1><p>state(car::MountainCarAgent) = car.state position(car::MountainCarAgent) = position(state(car)) velocity(car::MountainCarAgent) = velocity(state(car)) throttle(car::MountainCarAgent) = throttle(state(car)) mass(car::MountainCarAgent) = car.mass observable<em>state(car::MountainCarAgent) = observable</em>state(state(car))</p><p>set<em>position!(car::MountainCarAgent, position::Real) = set</em>position!(state(car), position) set<em>velocity!(car::MountainCarAgent, velocity::Real) = set</em>velocity!(state(car), velocity) set<em>throttle!(car::MountainCarAgent, throttle::Real) = set</em>throttle!(state(car), throttle) engine<em>power(car::MountainCarAgent) = car.engine</em>power friction<em>coefficient(car::MountainCarAgent) = car.friction</em>coefficient set<em>trajectory!(car::MountainCarAgent, trajectory) = set</em>trajectory!(state(car), trajectory) trajectory(car::MountainCarAgent) = trajectory(state(car))</p><pre><code class="nohighlight hljs">
Now we are in a shape where we can define the actual environment, which will contain a landscape function and a collection of Mountain Cars:</code></pre><p>julia struct MountainCarEnvironment     actors::Vector{MountainCarAgent}     landscape::Any end</p><p>MountainCarEnvironment(landscape) = MountainCarEnvironment([], landscape)</p><pre><code class="nohighlight hljs">
In order to encode the actions conducted by mountain car entities on the environment, we introduce a `Throttle` struct that clamps an input action between $-1$ and $1$:
</code></pre><p>julia struct Throttle     throttle::Real     Throttle(throttle::Real) = new(clamp(throttle, -1, 1)) end</p><pre><code class="nohighlight hljs">Our environment contains a field `actors`, however, we still have to tell `RxEnvironments` how to add entities to this field:</code></pre><p>julia function RxEnvironments.add<em>to</em>state!(environment::MountainCarEnvironment, agent::MountainCarAgent)     push!(environment.actors, agent) end</p><pre><code class="nohighlight hljs">### Environment dynamics
When simulating the environment dynamics we need to be able to calculate all forces exerted on the car at any point in time:
</code></pre><p>throttle(action::Throttle) = action.throttle friction(car::MountainCarAgent, velocity) = velocity * -friction_coefficient(car) gravitation(car::MountainCarAgent, position, landscape) =     mass(car) * -9.81 * sin(atan(ForwardDiff.derivative(landscape, position)))</p><pre><code class="nohighlight hljs">
### Solving the differential equations
We have set up the infrastructure with which we can save a trajectory of a moving object in its state, and retrieve this trajectory during future state updates. For this, we use the [`DifferentialEquations.jl`](https://docs.sciml.ai/DiffEqDocs/stable/) package, and we refer to the documentation of the `DifferentialEquations.jl` package for a more comprehensive explanation of solving differential equations in Julia. This section merely shows an example of the desired design pattern in `RxEnvironments.jl`. We have to compute the dynamics of the mountain car and save this in the state of the mountain car:</code></pre><h1 id="DifferentialEquations.jl-function-describing-the-environment-dynamics."><a class="docs-heading-anchor" href="#DifferentialEquations.jl-function-describing-the-environment-dynamics.">DifferentialEquations.jl function describing the environment dynamics.</a><a id="DifferentialEquations.jl-function-describing-the-environment-dynamics.-1"></a><a class="docs-heading-anchor-permalink" href="#DifferentialEquations.jl-function-describing-the-environment-dynamics." title="Permalink"></a></h1><p>function __mountain<em>car</em>dynamics(du, u, s, t)     agent, env = s     position, momentum = u     du[1] = momentum     du[2] =         throttle(agent) +         friction(agent, momentum) +         gravitation(agent, position, env.landscape) end</p><h1 id="Function-that-computes-a-trajectory-for-a-mountain-car-for-5-seconds-ahead-and-saves-this-result-in-the-state-of-the-corresponding-car."><a class="docs-heading-anchor" href="#Function-that-computes-a-trajectory-for-a-mountain-car-for-5-seconds-ahead-and-saves-this-result-in-the-state-of-the-corresponding-car.">Function that computes a trajectory for a mountain car for 5 seconds ahead and saves this result in the state of the corresponding car.</a><a id="Function-that-computes-a-trajectory-for-a-mountain-car-for-5-seconds-ahead-and-saves-this-result-in-the-state-of-the-corresponding-car.-1"></a><a class="docs-heading-anchor-permalink" href="#Function-that-computes-a-trajectory-for-a-mountain-car-for-5-seconds-ahead-and-saves-this-result-in-the-state-of-the-corresponding-car." title="Permalink"></a></h1><p>function <strong>compute<em>mountain</em>car<em>dynamics(     agent::MountainCarAgent,     environment::MountainCarEnvironment, )     T = 5.0     initial</em>state = [position(agent), velocity(agent)]     tspan = (0.0, T)     prob = ODEProblem(</strong>mountain<em>car</em>dynamics, initial<em>state, tspan, (agent, environment))     sol = solve(prob, Tsit5())     set</em>trajectory!(agent, MountainCarTrajectory(false, T, sol, T)) end</p><pre><code class="nohighlight hljs">
### Implementing `RxEnvironments` functions
All code we have written so far has served as setup for our environment, and we haven&#39;t written any core `RxEnvironments.jl` code yet. In this section we will write and elaborate on the necessary code to make our environment fully reactive. 

`RxEnvironments.jl` requires us to implement 3 functions specifically for our environment: `send!`, `receive!` and `update!`:
`send!(recipient, emitter)` determines the message `emitter` sends to `recipient`. In our example, this function describes how the environment presents an observation to the agent, as function of the environment state.
`receive!(recipient, emitter, observation)` determines how `observation` sent from `emitter` to `recipient` influences the internal state of `recipient`. In our example, this describes how a `Throttle` action from the agent changes the environment state.
`update!(entity, elapsed_time)` describes the state transition of `entity` for `elapsed_time` if there are no incoming observations. In our example, this is how the environment gravity and friction influence the position and velocity of the agent inbetween agent actions.
A notable detail is that, with our differential equations solution, we also have to check whenever we `update!` the environment if we have to recompute the trajectory for a mountain car, and whenever we `receive!` an action from an agent, that we should always recompute the trajectory.
</code></pre><p>julia </p><h1 id="The-agent-observes-a-noisy-estimate-of-its-actual-position-and-velocity"><a class="docs-heading-anchor" href="#The-agent-observes-a-noisy-estimate-of-its-actual-position-and-velocity">The agent observes a noisy estimate of its actual position and velocity</a><a id="The-agent-observes-a-noisy-estimate-of-its-actual-position-and-velocity-1"></a><a class="docs-heading-anchor-permalink" href="#The-agent-observes-a-noisy-estimate-of-its-actual-position-and-velocity" title="Permalink"></a></h1><p>RxEnvironments.send!(agent::MountainCarAgent, environment::MountainCarEnvironment) =     return rand(MvNormal(observable_state(agent), I(2)))</p><p>function RxEnvironments.receive!(     environment::MountainCarEnvironment,     agent::MountainCarAgent,     action::Throttle, )     # We always have to recompute the trajecory of an agent if this agent conducts an action     set<em>recompute!(trajectory(agent), true)     set</em>throttle!(agent, throttle(action) * engine_power(agent)) end</p><p>function update!(environment::MountainCarEnvironment, elapsed<em>time::Real)     # Update all actors in the environment     for agent in environment.actors         # If we have conducted an action or the current trajecory is valid for less than `elapsed</em>time` seconds, recompute         if recompute(trajectory(agent)) || time<em>left(trajectory(agent)) &lt; elapsed</em>time             __compute<em>mountain</em>car<em>dynamics(agent, environment)         end         # Bookkeeping for the trajecory, position and velocity         reduce</em>time<em>left!(trajectory(agent), elapsed</em>time)         new<em>state = trajectory(agent)[current</em>time(trajectory(agent))]         set<em>position!(agent, new</em>state[1])         set<em>velocity!(agent, new</em>state[2])     end end</p><pre><code class="nohighlight hljs">
With these funcitons we have specified the full environment behaviour, and the environment is now fully functional in `RxEnvironments.jl`. 
We can create the environment with the `RxEnvironment` factory method:</code></pre><p>julia engine<em>power = 0.6 friction</em>coefficient = 0.5 mass = 2 target = 1</p><p>env = RxEnvironment(MountainCarEnvironment(landscape)) agent = add!(             env,             MountainCarAgent(                 MountainCarState(-0.5, 0.0, 0.0),                 engine<em>power,                 friction</em>coefficient,                 mass,                 target,             ),         )</p><pre><code class="nohighlight hljs">
### Discrete-time Mountain Car
Classical control theory mainly deals with discrete-time environments, and it is actually very easy to convert the environment dynamics we have written in `RxEnvironments` to also define a discrete environment. In general, the following design pattern is very helpful:</code></pre><p>julia update!(env::YourEnvironment) = update!(env, dt)</p><pre><code class="nohighlight hljs">for your choice of `dt`. For our mountain car environment, we can set the default timestep to $0.1$ as follows:</code></pre><p>julia update!(env::MountainCarEnvironment) = update!(env, 0.1)</p><pre><code class="nohighlight hljs">This will still utilize all environment dynamics we have written for the continuous case, but will create a discrete-time environment. In order to create a discrete-time environment, please make sure to include the `discrete=true` keyword argument for the `RxEnvironment` factory method:
</code></pre><p>julia engine<em>power = 0.6 friction</em>coefficient = 0.5 mass = 2 target = 1</p><p>env = RxEnvironment(MountainCarEnvironment(landscape); discrete=true) agent = add!(             env,             MountainCarAgent(                 MountainCarState(-0.5, 0.0, 0.0),                 engine<em>power,                 friction</em>coefficient,                 mass,                 target,             ),         )</p><pre><code class="nohighlight hljs">### Animating the state of the environment
In order to animate the state of the environment, we have to install `GLMakie.jl` and implement the `plot_state` function for our environment.</code></pre><p>julia using GLMakie</p><p>function RxEnvironments.plot_state(ax, environment::MountainCarEnvironment)     x = range(-2.5, 2.5, 100)     y = environment.landscape.(x)     lines!(ax, x, y)     for agent in environment.actors         position = position(agent)         scatter!(ax, position, environment.landscape(position))     end end</p><pre><code class="nohighlight hljs">
Now we can call:</code></pre><p>julia animate<em>state(env) ``<code>on an existing</code>RxEnvironment<code>wrapping the</code>MountainCarEnvironment` and obtain a similar visualization: ![](../img/animate</em>state.png)</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting Started</a><a class="docs-footer-nextpage" href="../advanced_usage/">Advanced Usage »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 11 September 2023 14:02">Monday 11 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
